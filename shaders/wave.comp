#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x_id = 0) in;
layout (constant_id = 1) const int pyramidLevels = 24;

struct Element {
    uint index;
    uint score;
};

layout(set = 0, binding = 0) buffer Pyramid {
    Element[] elements;
} pyramid[pyramidLevels];

layout(push_constant) uniform Info {
    uint count;
    uint targetLevel;
    vec3 color;
} info;

layout(set = 1, binding = 0, rgba8) uniform image2D image;

layout(set = 1, binding = 1) buffer Input {
    ivec2[] data;
} inputData;

float length2(vec3 v) {
    return v.x * v.x + v.y * v.y + v.z * v.z;
}

void main() {
    if (gl_GlobalInvocationID.x >= info.count) {
        Element empty;
        empty.index = 0;
        empty.score = uint(-1);
        pyramid[info.targetLevel].elements[gl_GlobalInvocationID.x] = empty;
        return;
    }

    ivec2 pos = inputData.data[gl_GlobalInvocationID.x];
    ivec2[8] neighbors = ivec2[](
        pos + ivec2(-1, -1),
        pos + ivec2(-1,  0),
        pos + ivec2(-1,  1),
        pos + ivec2( 0, -1),
        pos + ivec2( 0,  1),
        pos + ivec2( 1, -1),
        pos + ivec2( 1,  0),
        pos + ivec2( 1,  1)
    );

    uint[8] scores;

    for (int i = 0; i < 8; i++) {
        scores[i] = uint(-1);
    }

    for (int i = 0; i < 8; i++) {
        ivec2 n = neighbors[i];
        vec4 color = imageLoad(image, n);
        if (color.a != 0) {
            float scoreF = length2(info.color - color.rgb);
            scores[i] = uint(round(scoreF));
        }
    }

    uint realScore = uint(-1);

    for (int i = 0; i < 8; i++) {
        if (scores[i] < realScore) {
            realScore = scores[i];
        }
    }

    Element e;
    e.score = realScore;
    e.index = gl_GlobalInvocationID.x;
    pyramid[info.targetLevel].elements[gl_GlobalInvocationID.x] = e;
}